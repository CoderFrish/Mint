From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: xuyin <1573880184@qq.com>
Date: Sat, 11 Jan 2025 14:48:48 +0800
Subject: [PATCH] Fixed `reload` command.


diff --git a/src/main/java/com/menthamc/mint/schedule/MintAsyncScheduled.java b/src/main/java/com/menthamc/mint/schedule/MintAsyncScheduled.java
new file mode 100644
index 0000000000000000000000000000000000000000..6ee2a12b644691c5fb118ad6b28d62253b6c6973
--- /dev/null
+++ b/src/main/java/com/menthamc/mint/schedule/MintAsyncScheduled.java
@@ -0,0 +1,120 @@
+package com.menthamc.mint.schedule;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.*;
+
+public class MintAsyncScheduled {
+    private final AsyncExecutor asyncExecutor;
+
+    public MintAsyncScheduled() {
+        this.asyncExecutor = new AsyncExecutor();
+    }
+
+    public void runNow(Runnable runnable) {
+        asyncExecutor.execute(runnable);
+    }
+
+    public void run(Runnable runnable) {
+        asyncExecutor.submit(runnable);
+    }
+
+    public void close() {
+        if (asyncExecutor.isTerminated()) {
+            asyncExecutor.shutdownNow();
+        }
+    }
+
+    private static class AsyncExecutor implements ExecutorService {
+        private final ThreadPoolExecutor executor;
+
+        private AsyncExecutor() {
+            this.executor = new ThreadPoolExecutor(
+                    Math.max(2, Runtime.getRuntime().availableProcessors() / 2),
+                    Integer.MAX_VALUE,
+                    30L,
+                    TimeUnit.SECONDS,
+                    new LinkedBlockingQueue<>()
+            );
+        }
+
+        @Override
+        public void shutdown() {
+            executor.shutdown();
+        }
+
+        @NotNull
+        @Override
+        public List<Runnable> shutdownNow() {
+            return executor.shutdownNow();
+        }
+
+        @Override
+        public boolean isShutdown() {
+            return executor.isShutdown();
+        }
+
+        @Override
+        public boolean isTerminated() {
+            return executor.isTerminated();
+        }
+
+        @Override
+        public boolean awaitTermination(long timeout, @NotNull TimeUnit unit) throws InterruptedException {
+            return executor.awaitTermination(timeout, unit);
+        }
+
+        @NotNull
+        @Override
+        public <T> Future<T> submit(@NotNull Callable<T> task) {
+            return executor.submit(task);
+        }
+
+        @NotNull
+        @Override
+        public <T> Future<T> submit(@NotNull Runnable task, T result) {
+            return executor.submit(task, result);
+        }
+
+        @NotNull
+        @Override
+        public Future<?> submit(@NotNull Runnable task) {
+            return executor.submit(task);
+        }
+
+        @NotNull
+        @Override
+        public <T> List<Future<T>> invokeAll(@NotNull Collection<? extends Callable<T>> tasks) throws InterruptedException {
+            return executor.invokeAll(tasks);
+        }
+
+        @NotNull
+        @Override
+        public <T> List<Future<T>> invokeAll(@NotNull Collection<? extends Callable<T>> tasks, long timeout, @NotNull TimeUnit unit) throws InterruptedException {
+            return executor.invokeAll(tasks, timeout, unit);
+        }
+
+        @NotNull
+        @Override
+        public <T> T invokeAny(@NotNull Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {
+            return executor.invokeAny(tasks);
+        }
+
+        @Override
+        public <T> T invokeAny(@NotNull Collection<? extends Callable<T>> tasks, long timeout, @NotNull TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
+            return executor.invokeAny(tasks, timeout, unit);
+        }
+
+        @Override
+        public void close() {
+            executor.close();
+        }
+
+        @Override
+        public void execute(@NotNull Runnable command) {
+            executor.execute(command);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 4ed79a51c89d54a7b2ab65a99b5b09cc807f4d4e..f13cd68bf1ab32040e3cb7cdc212be5cce97259e 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1,5 +1,15 @@
 package net.minecraft.server;
 
+import ca.spottedleaf.leafprofiler.LProfilerRegistry;
+import ca.spottedleaf.leafprofiler.RegionizedProfiler;
+import ca.spottedleaf.moonrise.common.util.TickThread;
+import ca.spottedleaf.moonrise.patches.chunk_system.io.RegionFileIOThread;
+import ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager;
+import ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer;
+import co.aikar.timings.Timing;
+import co.aikar.timings.TimingsManager;
+import com.destroystokyo.paper.event.server.ServerTickEndEvent;
+import com.destroystokyo.paper.event.server.ServerTickStartEvent;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableList;
@@ -9,11 +19,33 @@ import com.google.common.base.Stopwatch;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import com.menthamc.mint.schedule.MintAsyncScheduled;
 import com.mojang.authlib.GameProfile;
 import com.mojang.authlib.GameProfileRepository;
 import com.mojang.authlib.minecraft.MinecraftSessionService;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.ServerBuildInfo;
+import io.papermc.paper.adventure.ImprovedChatDecorator;
+import io.papermc.paper.adventure.PaperAdventure;
+import io.papermc.paper.annotation.DoNotUse;
+import io.papermc.paper.command.brigadier.PaperBrigadier;
+import io.papermc.paper.command.brigadier.PaperCommands;
+import io.papermc.paper.configuration.GlobalConfiguration;
+import io.papermc.paper.configuration.PaperConfigurations;
+import io.papermc.paper.event.server.ServerResourcesReloadedEvent;
+import io.papermc.paper.log.CustomLogManager;
+import io.papermc.paper.plugin.PluginInitializerManager;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventRunner;
+import io.papermc.paper.plugin.lifecycle.event.registrar.ReloadableRegistrarEvent;
+import io.papermc.paper.plugin.lifecycle.event.types.LifecycleEvents;
+import io.papermc.paper.threadedregions.*;
+import io.papermc.paper.threadedregions.scheduler.FoliaRegionScheduler;
+import io.papermc.paper.util.LogManagerShutdownThread;
+import io.papermc.paper.util.MCUtil;
+import io.papermc.paper.util.ServerStopRejectedExecutionException;
+import io.papermc.paper.util.TraceUtil;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectArraySet;
@@ -24,29 +56,20 @@ import java.io.IOException;
 import java.lang.management.ManagementFactory;
 import java.lang.management.ThreadInfo;
 import java.lang.management.ThreadMXBean;
+import java.math.BigDecimal;
+import java.math.RoundingMode;
 import java.net.Proxy;
 import java.nio.file.FileStore;
 import java.nio.file.Files;
 import java.nio.file.LinkOption;
 import java.nio.file.Path;
 import java.security.KeyPair;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
+import java.util.*;
 import java.util.Map.Entry;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Set;
-import java.util.UUID;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.Executor;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.locks.LockSupport;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
 import java.util.function.Function;
@@ -54,14 +77,10 @@ import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
-import net.minecraft.CrashReport;
-import net.minecraft.CrashReportCategory;
-import net.minecraft.FileUtil;
-import net.minecraft.ReportType;
-import net.minecraft.ReportedException;
-import net.minecraft.SharedConstants;
-import net.minecraft.SystemReport;
-import net.minecraft.Util;
+
+import net.kyori.adventure.text.logger.slf4j.ComponentLogger;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import net.minecraft.*;
 import net.minecraft.commands.CommandSource;
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.commands.Commands;
@@ -82,6 +101,7 @@ import net.minecraft.network.protocol.status.ServerStatus;
 import net.minecraft.obfuscate.DontObfuscate;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.*;
 import net.minecraft.server.packs.PackType;
 import net.minecraft.server.packs.repository.Pack;
 import net.minecraft.server.packs.repository.PackRepository;
@@ -144,18 +164,40 @@ import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.border.WorldBorder;
 import net.minecraft.world.level.chunk.storage.ChunkIOErrorReporter;
 import net.minecraft.world.level.chunk.storage.RegionStorageInfo;
+import net.minecraft.world.level.dimension.BuiltinDimensionTypes;
 import net.minecraft.world.level.dimension.LevelStem;
 import net.minecraft.world.level.levelgen.WorldOptions;
 import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
 import net.minecraft.world.level.storage.WorldData;
+import net.minecraft.world.scores.PlayerTeam;
+import net.minecrell.terminalconsole.TerminalConsoleAppender;
+import org.apache.commons.io.FileUtils;
+import org.apache.commons.lang3.StringUtils;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.block.data.CraftBlockData;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.craftbukkit.generator.CraftWorldInfo;
+import org.bukkit.craftbukkit.help.SimpleHelpMap;
+import org.bukkit.craftbukkit.scoreboard.CraftScoreboardManager;
+import org.bukkit.craftbukkit.util.ServerShutdownThread;
+import org.bukkit.event.player.PlayerKickEvent;
+import org.bukkit.event.world.WorldInitEvent;
+import org.bukkit.event.world.WorldLoadEvent;
+import org.bukkit.generator.BiomeProvider;
+import org.bukkit.generator.ChunkGenerator;
+import org.bukkit.generator.WorldInfo;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.PluginLoadOrder;
 import org.slf4j.Logger;
 
 // CraftBukkit start
 import com.mojang.serialization.Dynamic;
 import com.mojang.serialization.Lifecycle;
 import java.io.File;
-import java.util.Random;
 // import jline.console.ConsoleReader; // Paper
 import joptsimple.OptionSet;
 import net.minecraft.nbt.NbtException;
@@ -163,12 +205,6 @@ import net.minecraft.nbt.ReportedNbtException;
 import net.minecraft.server.bossevents.CustomBossEvents;
 import net.minecraft.server.dedicated.DedicatedServer;
 import net.minecraft.server.dedicated.DedicatedServerProperties;
-import net.minecraft.server.level.DemoMode;
-import net.minecraft.server.level.PlayerRespawnLogic;
-import net.minecraft.server.level.ServerChunkCache;
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.server.level.ServerPlayerGameMode;
 import net.minecraft.server.level.progress.ChunkProgressListener;
 import net.minecraft.server.level.progress.ChunkProgressListenerFactory;
 import net.minecraft.server.network.ServerConnectionListener;
@@ -197,12 +233,14 @@ import org.bukkit.event.server.ServerLoadEvent;
 // CraftBukkit end
 
 import co.aikar.timings.MinecraftTimings; // Paper
+import org.spigotmc.SpigotConfig;
+import org.spigotmc.WatchdogThread;
 
-public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements ServerInfo, ChunkIOErrorReporter, CommandSource, AutoCloseable, ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer { // Paper - rewrite chunk system
+public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements ServerInfo, ChunkIOErrorReporter, CommandSource, AutoCloseable, ChunkSystemMinecraftServer { // Paper - rewrite chunk system
 
     private static MinecraftServer SERVER; // Paper
     public static final Logger LOGGER = LogUtils.getLogger();
-    public static final net.kyori.adventure.text.logger.slf4j.ComponentLogger COMPONENT_LOGGER = net.kyori.adventure.text.logger.slf4j.ComponentLogger.logger(LOGGER.getName()); // Paper
+    public static final ComponentLogger COMPONENT_LOGGER = ComponentLogger.logger(LOGGER.getName()); // Paper
     public static final String VANILLA_BRAND = "vanilla";
     private static final float AVERAGE_TICK_TIME_SMOOTHING = 0.8F;
     private static final int TICK_STATS_SPAN = 100;
@@ -229,7 +267,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private Consumer<Path> onMetricsRecordingFinished;
     private boolean willStartRecordingMetrics;
     @Nullable
-    private MinecraftServer.TimeProfiler debugCommandProfiler;
+    private TimeProfiler debugCommandProfiler;
     private boolean debugCommandProfilerDelayStart;
     private ServerConnectionListener connection;
     public final ChunkProgressListenerFactory progressListenerFactory;
@@ -289,7 +327,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public final Executor executor;
     @Nullable
     private String serverId;
-    public MinecraftServer.ReloadableResources resources;
+    public ReloadableResources resources;
     private final StructureTemplateManager structureTemplateManager;
     private final ServerTickRateManager tickRateManager;
     protected WorldData worldData;
@@ -299,11 +337,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     // CraftBukkit start
     public final WorldLoader.DataLoadContext worldLoader;
-    public org.bukkit.craftbukkit.CraftServer server;
+    public CraftServer server;
     public OptionSet options;
-    public org.bukkit.command.ConsoleCommandSender console;
+    public ConsoleCommandSender console;
     //public static int currentTick; // Paper - improve tick loop // Folia - region threading
-    public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>();
+    public Queue<Runnable> processQueue = new ConcurrentLinkedQueue<Runnable>();
     public int autosavePeriod;
     // Paper - don't store the vanilla dispatcher
     public boolean forceTicks; // Paper - Improved watchdog support
@@ -315,22 +353,27 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     @Deprecated(forRemoval = true) // Paper
     public final double[] recentTps = new double[ 3 ];
     // Spigot end
-    public final io.papermc.paper.configuration.PaperConfigurations paperConfigurations; // Paper - add paper configuration files
+    public final PaperConfigurations paperConfigurations; // Paper - add paper configuration files
     public boolean isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
 
     public volatile Thread shutdownThread; // Paper
     public volatile boolean abnormalExit = false; // Paper
     public static final long SERVER_INIT = System.nanoTime(); // Paper - Lag compensation
+    private final MintAsyncScheduled mintAsyncScheduled = new MintAsyncScheduled();
 
     // Folia start - regionised ticking
-    public final io.papermc.paper.threadedregions.RegionizedServer regionizedServer = new io.papermc.paper.threadedregions.RegionizedServer();
+    public final RegionizedServer regionizedServer = new RegionizedServer();
 
     @Override
     public void execute(Runnable runnable) {
-        if (true) {
-            throw new UnsupportedOperationException();
+        if(false) {
+            if (true) {
+                throw new UnsupportedOperationException();
+            }
+            super.execute(runnable);
         }
-        super.execute(runnable);
+
+        mintAsyncScheduled.run(runnable);
     }
 
     @Override
@@ -352,7 +395,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     public static <S extends MinecraftServer> S spin(Function<Thread, S> serverFactory) {
         AtomicReference<S> atomicreference = new AtomicReference();
-        Thread thread = new ca.spottedleaf.moonrise.common.util.TickThread(() -> { // Paper - rewrite chunk system
+        Thread thread = new TickThread(() -> { // Paper - rewrite chunk system
             ((MinecraftServer) atomicreference.get()).runServer();
         }, "Server thread");
 
@@ -385,13 +428,13 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     // Folia - region threading - moved to regionized data
 
-    private boolean tickMidTickTasks(final io.papermc.paper.threadedregions.RegionizedWorldData worldData) { // Folia - region threading
+    private boolean tickMidTickTasks(final RegionizedWorldData worldData) { // Folia - region threading
         return worldData.world.getChunkSource().pollTask(); // Folia - region threading
     }
 
     @Override
     public final void moonrise$executeMidTickTasks() {
-        io.papermc.paper.threadedregions.RegionizedWorldData worldData = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData(); // Folia - region threading
+        RegionizedWorldData worldData = TickRegionScheduler.getCurrentRegionizedWorldData(); // Folia - region threading
         final long startTime = System.nanoTime();
         if ((startTime - worldData.lastMidTickExecute) <= CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME || (startTime - worldData.lastMidTickExecuteFailure) <= TASK_EXECUTION_FAILURE_BACKOFF) { // Folia - region threading
             // it's shown to be bad to constantly hit the queue (chunk loads slow to a crawl), even if no tasks are executed.
@@ -455,7 +498,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         } else {
             this.proxy = proxy;
             this.packRepository = resourcepackrepository;
-            this.resources = new MinecraftServer.ReloadableResources(worldstem.resourceManager(), worldstem.dataPackResources());
+            this.resources = new ReloadableResources(worldstem.resourceManager(), worldstem.dataPackResources());
             this.services = services;
             if (services.profileCache() != null) {
                 services.profileCache().setExecutor(this);
@@ -503,8 +546,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
         */
         // Paper end
-        io.papermc.paper.util.LogManagerShutdownThread.unhook(); // Paper
-        Runtime.getRuntime().addShutdownHook(new org.bukkit.craftbukkit.util.ServerShutdownThread(this));
+        LogManagerShutdownThread.unhook(); // Paper
+        Runtime.getRuntime().addShutdownHook(new ServerShutdownThread(this));
         // CraftBukkit end
         this.paperConfigurations = services.paperConfigurations(); // Paper - add paper configuration files
     }
@@ -569,7 +612,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 dimension = -999;
             }
 
-            String worldType = (dimension == -999) ? dimensionKey.location().getNamespace() + "_" + dimensionKey.location().getPath() : org.bukkit.World.Environment.getEnvironment(dimension).toString().toLowerCase(Locale.ROOT);
+            String worldType = (dimension == -999) ? dimensionKey.location().getNamespace() + "_" + dimensionKey.location().getPath() : World.Environment.getEnvironment(dimension).toString().toLowerCase(Locale.ROOT);
             String name = (dimensionKey == LevelStem.OVERWORLD) ? s : s + "_" + worldType;
             if (dimension != 0) {
                 File newWorld = LevelStorageSource.getStorageFolder(new File(name).toPath(), dimensionKey).toFile();
@@ -591,7 +634,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                             // Migrate world data too.
                             try {
                                 com.google.common.io.Files.copy(oldLevelDat, new File(new File(name), "level.dat"));
-                                org.apache.commons.io.FileUtils.copyDirectory(new File(new File(s), "data"), new File(new File(name), "data"));
+                                FileUtils.copyDirectory(new File(new File(s), "data"), new File(new File(name), "data"));
                             } catch (IOException exception) {
                                 MinecraftServer.LOGGER.warn("Unable to migrate world data.");
                             }
@@ -651,8 +694,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 dynamic = null;
             }
 
-            org.bukkit.generator.ChunkGenerator gen = this.server.getGenerator(name);
-            org.bukkit.generator.BiomeProvider biomeProvider = this.server.getBiomeProvider(name);
+            ChunkGenerator gen = this.server.getGenerator(name);
+            BiomeProvider biomeProvider = this.server.getBiomeProvider(name);
 
             PrimaryLevelData worlddata;
             WorldLoader.DataLoadContext worldloader_a = this.worldLoader;
@@ -685,7 +728,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             }
             worlddata.checkName(name); // CraftBukkit - Migration did not rewrite the level.dat; This forces 1.8 to take the last loaded world as respawn (in this case the end)
             if (this.options.has("forceUpgrade")) {
-                net.minecraft.server.Main.forceUpgrade(worldSession, DataFixers.getDataFixer(), this.options.has("eraseCache"), () -> {
+                Main.forceUpgrade(worldSession, DataFixers.getDataFixer(), this.options.has("eraseCache"), () -> {
                     return true;
                 }, iregistrycustom_dimension, this.options.has("recreateRegionFiles"));
             }
@@ -698,7 +741,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             List<CustomSpawner> list = ImmutableList.of(new PhantomSpawner(), new PatrolSpawner(), new CatSpawner(), new VillageSiege(), new WanderingTraderSpawner(iworlddataserver));
             LevelStem worlddimension = (LevelStem) dimensions.get(dimensionKey);
 
-            org.bukkit.generator.WorldInfo worldInfo = new org.bukkit.craftbukkit.generator.CraftWorldInfo(iworlddataserver, worldSession, org.bukkit.World.Environment.getEnvironment(dimension), worlddimension.type().value(), worlddimension.generator(), this.registryAccess()); // Paper - Expose vanilla BiomeProvider from WorldInfo
+            WorldInfo worldInfo = new CraftWorldInfo(iworlddataserver, worldSession, World.Environment.getEnvironment(dimension), worlddimension.type().value(), worlddimension.generator(), this.registryAccess()); // Paper - Expose vanilla BiomeProvider from WorldInfo
             if (biomeProvider == null && gen != null) {
                 biomeProvider = gen.getDefaultBiomeProvider(worldInfo);
             }
@@ -711,21 +754,21 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
                 ChunkProgressListener worldloadlistener = this.progressListenerFactory.create(this.worldData.getGameRules().getInt(GameRules.RULE_SPAWN_CHUNK_RADIUS));
 
-                world = new ServerLevel(this, this.executor, worldSession, iworlddataserver, worldKey, worlddimension, worldloadlistener, flag, j, list, true, (RandomSequences) null, org.bukkit.World.Environment.getEnvironment(dimension), gen, biomeProvider);
+                world = new ServerLevel(this, this.executor, worldSession, iworlddataserver, worldKey, worlddimension, worldloadlistener, flag, j, list, true, (RandomSequences) null, World.Environment.getEnvironment(dimension), gen, biomeProvider);
                 DimensionDataStorage worldpersistentdata = world.getDataStorage();
                 this.readScoreboard(worldpersistentdata);
-                this.server.scoreboardManager = new org.bukkit.craftbukkit.scoreboard.CraftScoreboardManager(this, world.getScoreboard());
+                this.server.scoreboardManager = new CraftScoreboardManager(this, world.getScoreboard());
                 this.commandStorage = new CommandStorage(worldpersistentdata);
             } else {
                 ChunkProgressListener worldloadlistener = this.progressListenerFactory.create(this.worldData.getGameRules().getInt(GameRules.RULE_SPAWN_CHUNK_RADIUS));
                 // Paper start - option to use the dimension_type to check if spawners should be added. I imagine mojang will add some datapack-y way of managing this in the future.
                 final List<CustomSpawner> spawners;
-                if (io.papermc.paper.configuration.GlobalConfiguration.get().misc.useDimensionTypeForCustomSpawners && this.registryAccess().registryOrThrow(Registries.DIMENSION_TYPE).getResourceKey(worlddimension.type().value()).orElseThrow() == net.minecraft.world.level.dimension.BuiltinDimensionTypes.OVERWORLD) {
+                if (GlobalConfiguration.get().misc.useDimensionTypeForCustomSpawners && this.registryAccess().registryOrThrow(Registries.DIMENSION_TYPE).getResourceKey(worlddimension.type().value()).orElseThrow() == BuiltinDimensionTypes.OVERWORLD) {
                     spawners = list;
                 } else {
                     spawners = Collections.emptyList();
                 }
-                world = new ServerLevel(this, this.executor, worldSession, iworlddataserver, worldKey, worlddimension, worldloadlistener, flag, j, spawners, true, this.overworld().getRandomSequences(), org.bukkit.World.Environment.getEnvironment(dimension), gen, biomeProvider);
+                world = new ServerLevel(this, this.executor, worldSession, iworlddataserver, worldKey, worlddimension, worldloadlistener, flag, j, spawners, true, this.overworld().getRandomSequences(), World.Environment.getEnvironment(dimension), gen, biomeProvider);
                 // Paper end - option to use the dimension_type to check if spawners should be added
             }
 
@@ -741,7 +784,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 for (int currZ = -loadRegionRadius; currZ <= loadRegionRadius; ++currZ) {
                     ChunkPos pos = new ChunkPos(currX, currZ);
                     world.chunkSource.addTicketAtLevel(
-                        net.minecraft.server.level.TicketType.UNKNOWN, pos, ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager.MAX_TICKET_LEVEL, pos
+                        TicketType.UNKNOWN, pos, ChunkHolderManager.MAX_TICKET_LEVEL, pos
                     );
                 }
             }
@@ -758,31 +801,31 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         for (ServerLevel worldserver : this.getAllLevels()) {
             this.prepareLevels(worldserver.getChunkSource().chunkMap.progressListener, worldserver);
             // Paper - rewrite chunk system
-            io.papermc.paper.threadedregions.RegionizedServer.getInstance().addWorld(worldserver); // Folia - region threading
-            this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldLoadEvent(worldserver.getWorld()));
+            RegionizedServer.getInstance().addWorld(worldserver); // Folia - region threading
+            this.server.getPluginManager().callEvent(new WorldLoadEvent(worldserver.getWorld()));
         }
 
         // Paper start - Configurable player collision; Handle collideRule team for player collision toggle
         final ServerScoreboard scoreboard = this.getScoreboard();
-        final java.util.Collection<String> toRemove = scoreboard.getPlayerTeams().stream().filter(team -> team.getName().startsWith("collideRule_")).map(net.minecraft.world.scores.PlayerTeam::getName).collect(java.util.stream.Collectors.toList());
+        final Collection<String> toRemove = scoreboard.getPlayerTeams().stream().filter(team -> team.getName().startsWith("collideRule_")).map(PlayerTeam::getName).collect(Collectors.toList());
         for (String teamName : toRemove) {
             scoreboard.removePlayerTeam(scoreboard.getPlayerTeam(teamName)); // Clean up after ourselves
         }
 
-        if (!io.papermc.paper.configuration.GlobalConfiguration.get().collisions.enablePlayerCollisions) {
-            this.getPlayerList().collideRuleTeamName = org.apache.commons.lang3.StringUtils.left("collideRule_" + java.util.concurrent.ThreadLocalRandom.current().nextInt(), 16);
-            net.minecraft.world.scores.PlayerTeam collideTeam = scoreboard.addPlayerTeam(this.getPlayerList().collideRuleTeamName);
+        if (!GlobalConfiguration.get().collisions.enablePlayerCollisions) {
+            this.getPlayerList().collideRuleTeamName = StringUtils.left("collideRule_" + ThreadLocalRandom.current().nextInt(), 16);
+            PlayerTeam collideTeam = scoreboard.addPlayerTeam(this.getPlayerList().collideRuleTeamName);
             collideTeam.setSeeFriendlyInvisibles(false); // Because we want to mimic them not being on a team at all
         }
         // Paper end - Configurable player collision
 
-        this.server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.POSTWORLD);
+        this.server.enablePlugins(PluginLoadOrder.POSTWORLD);
         this.server.spark.registerCommandBeforePlugins(this.server); // Paper - spark
         this.server.spark.enableAfterPlugins(this.server); // Paper - spark
-        if (io.papermc.paper.plugin.PluginInitializerManager.instance().pluginRemapper != null) io.papermc.paper.plugin.PluginInitializerManager.instance().pluginRemapper.pluginsEnabled(); // Paper - Remap plugins
-        io.papermc.paper.command.brigadier.PaperCommands.INSTANCE.setValid(); // Paper - reset invalid state for event fire below
-        io.papermc.paper.plugin.lifecycle.event.LifecycleEventRunner.INSTANCE.callReloadableRegistrarEvent(io.papermc.paper.plugin.lifecycle.event.types.LifecycleEvents.COMMANDS, io.papermc.paper.command.brigadier.PaperCommands.INSTANCE, org.bukkit.plugin.Plugin.class, io.papermc.paper.plugin.lifecycle.event.registrar.ReloadableRegistrarEvent.Cause.INITIAL); // Paper - call commands event for regular plugins
-        ((org.bukkit.craftbukkit.help.SimpleHelpMap) this.server.getHelpMap()).initializeCommands();
+        if (PluginInitializerManager.instance().pluginRemapper != null) PluginInitializerManager.instance().pluginRemapper.pluginsEnabled(); // Paper - Remap plugins
+        PaperCommands.INSTANCE.setValid(); // Paper - reset invalid state for event fire below
+        LifecycleEventRunner.INSTANCE.callReloadableRegistrarEvent(LifecycleEvents.COMMANDS, PaperCommands.INSTANCE, Plugin.class, ReloadableRegistrarEvent.Cause.INITIAL); // Paper - call commands event for regular plugins
+        ((SimpleHelpMap) this.server.getHelpMap()).initializeCommands();
         this.server.getPluginManager().callEvent(new ServerLoadEvent(ServerLoadEvent.LoadType.STARTUP));
         this.connection.acceptConnections();
     }
@@ -795,7 +838,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
         WorldBorder worldborder = worldserver.getWorldBorder();
         worldborder.applySettings(iworlddataserver.getWorldBorder()); // CraftBukkit - move up so that WorldBorder is set during WorldInitEvent
-        this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldInitEvent(worldserver.getWorld())); // CraftBukkit - SPIGOT-5569: Call WorldInitEvent before any chunks are generated
+        this.server.getPluginManager().callEvent(new WorldInitEvent(worldserver.getWorld())); // CraftBukkit - SPIGOT-5569: Call WorldInitEvent before any chunks are generated
 
         if (!iworlddataserver.isInitialized()) {
             try {
@@ -831,7 +874,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             // CraftBukkit start
             if (world.generator != null) {
                 Random rand = new Random(world.getSeed());
-                org.bukkit.Location spawn = world.generator.getFixedSpawnLocation(world.getWorld(), rand);
+                Location spawn = world.generator.getFixedSpawnLocation(world.getWorld(), rand);
 
                 if (spawn != null) {
                     if (spawn.getWorld() != world.getWorld()) {
@@ -1044,18 +1087,18 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     // CraftBukkit end
 
     // Folia start - region threading
-    private final java.util.concurrent.atomic.AtomicBoolean hasStartedShutdownThread = new java.util.concurrent.atomic.AtomicBoolean();
+    private final AtomicBoolean hasStartedShutdownThread = new AtomicBoolean();
 
     private void haltServerRegionThreading() {
         if (this.hasStartedShutdownThread.getAndSet(true)) {
             // already started shutdown
             return;
         }
-        new io.papermc.paper.threadedregions.RegionShutdownThread("Region shutdown thread").start();
+        new RegionShutdownThread("Region shutdown thread").start();
     }
 
     public void haltCurrentRegion() {
-        if (!ca.spottedleaf.moonrise.common.util.TickThread.isShutdownThread()) {
+        if (!TickThread.isShutdownThread()) {
             throw new IllegalStateException();
         }
     }
@@ -1065,10 +1108,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // Folia start - region threading
         // halt scheduler
         // don't wait, we may be on a scheduler thread
-        io.papermc.paper.threadedregions.TickRegions.getScheduler().halt(false, 0L);
+        TickRegions.getScheduler().halt(false, 0L);
         // cannot run shutdown logic on this thread, as it may be a scheduler
         if (true) {
-            if (!ca.spottedleaf.moonrise.common.util.TickThread.isShutdownThread()) {
+            if (!TickThread.isShutdownThread()) {
                 this.haltServerRegionThreading();
                 return;
             } // else: fall through to regular stop logic
@@ -1079,10 +1122,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             if (this.hasStopped) return;
             this.hasStopped = true;
         }
-        if (!hasLoggedStop && isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread("Server stopped"); // Paper - Debugging
+        if (!hasLoggedStop && isDebugging()) TraceUtil.dumpTraceForThread("Server stopped"); // Paper - Debugging
         // Paper start - kill main thread, and kill it hard
         shutdownThread = Thread.currentThread();
-        org.spigotmc.WatchdogThread.doStop(); // Paper
+        WatchdogThread.doStop(); // Paper
         // Paper end
         // CraftBukkit end
         if (this.metricsRecorder.isRecording()) {
@@ -1099,7 +1142,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             this.server.waitForAsyncTasksShutdown(); // Paper - Wait for Async Tasks during shutdown
         }
         // CraftBukkit end
-        if (io.papermc.paper.plugin.PluginInitializerManager.instance().pluginRemapper != null) io.papermc.paper.plugin.PluginInitializerManager.instance().pluginRemapper.shutdown(); // Paper - Plugin remapping
+        if (PluginInitializerManager.instance().pluginRemapper != null) PluginInitializerManager.instance().pluginRemapper.shutdown(); // Paper - Plugin remapping
         this.getConnection().stop();
         this.isSaving = true;
         if (this.playerList != null) {
@@ -1161,24 +1204,24 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             MinecraftServer.LOGGER.error("Failed to unlock level {}", this.storageSource.getLevelId(), ioexception1);
         }
         // Spigot start
-        io.papermc.paper.util.MCUtil.asyncExecutor.shutdown(); // Paper
-        try { io.papermc.paper.util.MCUtil.asyncExecutor.awaitTermination(30, java.util.concurrent.TimeUnit.SECONDS); // Paper
-        } catch (java.lang.InterruptedException ignored) {} // Paper
-        if (org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly) {
+        MCUtil.asyncExecutor.shutdown(); // Paper
+        try { MCUtil.asyncExecutor.awaitTermination(30, TimeUnit.SECONDS); // Paper
+        } catch (InterruptedException ignored) {} // Paper
+        if (SpigotConfig.saveUserCacheOnStopOnly) {
             MinecraftServer.LOGGER.info("Saving usercache.json");
             this.getProfileCache().save(false); // Paper - Perf: Async GameProfileCache saving
         }
         // Spigot end
 
         // Paper end - Improved watchdog support; move final shutdown items here
-        ca.spottedleaf.moonrise.patches.chunk_system.io.RegionFileIOThread.deinit(); // Paper - rewrite chunk system
+        RegionFileIOThread.deinit(); // Paper - rewrite chunk system
         // Paper start - move final shutdown items here
         Util.shutdownExecutors();
         try {
-            net.minecrell.terminalconsole.TerminalConsoleAppender.close(); // Paper - Use TerminalConsoleAppender
+            TerminalConsoleAppender.close(); // Paper - Use TerminalConsoleAppender
         } catch (final Exception ignored) {
         }
-        io.papermc.paper.log.CustomLogManager.forceReset(); // Paper - Reset loggers after shutdown
+        CustomLogManager.forceReset(); // Paper - Reset loggers after shutdown
         this.onServerExit();
         // Paper end - Improved watchdog support
     }
@@ -1202,7 +1245,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public void safeShutdown(boolean waitForShutdown, boolean isRestarting) {
         this.isRestarting = isRestarting;
         this.hasLoggedStop = true; // Paper - Debugging
-        if (isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread("Server stopped"); // Paper - Debugging
+        if (isDebugging()) TraceUtil.dumpTraceForThread("Server stopped"); // Paper - Debugging
         // Paper end
         this.running = false;
         this.stopServer(); // Folia - region threading
@@ -1234,16 +1277,16 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public static class RollingAverage {
         private final int size;
         private long time;
-        private java.math.BigDecimal total;
+        private BigDecimal total;
         private int index = 0;
-        private final java.math.BigDecimal[] samples;
+        private final BigDecimal[] samples;
         private final long[] times;
 
         RollingAverage(int size) {
             this.size = size;
             this.time = size * SEC_IN_NANO;
             this.total = dec(TPS).multiply(dec(SEC_IN_NANO)).multiply(dec(size));
-            this.samples = new java.math.BigDecimal[size];
+            this.samples = new BigDecimal[size];
             this.times = new long[size];
             for (int i = 0; i < size; i++) {
                 this.samples[i] = dec(TPS);
@@ -1251,10 +1294,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             }
         }
 
-        private static java.math.BigDecimal dec(long t) {
-            return new java.math.BigDecimal(t);
+        private static BigDecimal dec(long t) {
+            return new BigDecimal(t);
         }
-        public void add(java.math.BigDecimal x, long t) {
+        public void add(BigDecimal x, long t) {
             time -= times[index];
             total = total.subtract(samples[index].multiply(dec(times[index])));
             samples[index] = x;
@@ -1267,10 +1310,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
 
         public double getAverage() {
-            return total.divide(dec(time), 30, java.math.RoundingMode.HALF_UP).doubleValue();
+            return total.divide(dec(time), 30, RoundingMode.HALF_UP).doubleValue();
         }
     }
-    private static final java.math.BigDecimal TPS_BASE = new java.math.BigDecimal(1E9).multiply(new java.math.BigDecimal(SAMPLE_INTERVAL));
+    private static final BigDecimal TPS_BASE = new BigDecimal(1E9).multiply(new BigDecimal(SAMPLE_INTERVAL));
     // Paper end
     // Spigot End
 
@@ -1287,8 +1330,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
             // Folia start - region threading
             if (true) {
-                io.papermc.paper.threadedregions.RegionizedServer.getInstance().init(); // Folia - region threading - only after loading worlds
-                String doneTime = String.format(java.util.Locale.ROOT, "%.3fs", (double) (Util.getNanos() - serverStartTime) / 1.0E9D);
+                RegionizedServer.getInstance().init(); // Folia - region threading - only after loading worlds
+                String doneTime = String.format(Locale.ROOT, "%.3fs", (double) (Util.getNanos() - serverStartTime) / 1.0E9D);
                 LOGGER.info("Done ({})! For help, type \"help\"", doneTime);
                 for (;;) {
                     try {
@@ -1307,18 +1350,18 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             // anything at 3+ won't be caught here but also will trip watchdog....
             // tasks are default scheduled at -1 + delay, and first tick will tick at 1
             final long actualDoneTimeMs = System.currentTimeMillis() - org.bukkit.craftbukkit.Main.BOOT_TIME.toEpochMilli(); // Paper - Add total time
-            LOGGER.info("Done ({})! For help, type \"help\"", String.format(java.util.Locale.ROOT, "%.3fs", actualDoneTimeMs / 1000.00D)); // Paper - Add total time
+            LOGGER.info("Done ({})! For help, type \"help\"", String.format(Locale.ROOT, "%.3fs", actualDoneTimeMs / 1000.00D)); // Paper - Add total time
             this.server.spark.enableBeforePlugins(); // Paper - spark
-            org.spigotmc.WatchdogThread.tick();
+            WatchdogThread.tick();
             // Paper end - Improved Watchdog Support
-            org.spigotmc.WatchdogThread.hasStarted = true; // Paper
+            WatchdogThread.hasStarted = true; // Paper
             Arrays.fill( this.recentTps, 20 );
             // Paper start - further improve server tick loop
             long tickSection = Util.getNanos();
             long currentTime;
             // Paper end - further improve server tick loop
             // Paper start - Add onboarding message for initial server start
-            if (io.papermc.paper.configuration.GlobalConfiguration.isFirstStart) {
+            if (GlobalConfiguration.isFirstStart) {
                 LOGGER.info("*************************************************************************************");
                 LOGGER.info("This is the first time you're starting this server.");
                 LOGGER.info("It's recommended you read our 'Getting Started' documentation for guidance.");
@@ -1352,7 +1395,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 currentTime = Util.getNanos();
                 if (false) { // Folia - region threading
                     final long diff = currentTime - tickSection;
-                    final java.math.BigDecimal currentTps = TPS_BASE.divide(new java.math.BigDecimal(diff), 30, java.math.RoundingMode.HALF_UP);
+                    final BigDecimal currentTps = TPS_BASE.divide(new BigDecimal(diff), 30, RoundingMode.HALF_UP);
                     tps1.add(currentTps, diff);
                     tps5.add(currentTps, diff);
                     tps15.add(currentTps, diff);
@@ -1518,7 +1561,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     private void executeModerately() {
         this.runAllTasks();
-        java.util.concurrent.locks.LockSupport.parkNanos("executing tasks", 1000L);
+        LockSupport.parkNanos("executing tasks", 1000L);
         // CraftBukkit end
     }
 
@@ -1653,8 +1696,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     // Folia start - region threading
     public void tickServer(long startTime, long scheduledEnd, long targetBuffer,
-                           io.papermc.paper.threadedregions.TickRegions.TickRegionData region) {
-        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
+                           TickRegions.TickRegionData region) {
+        final RegionizedProfiler.Handle profiler = TickRegionScheduler.getProfiler(); // Folia - profiler
         if (region != null) {
             region.world.getCurrentWorldData().updateTickData();
             if (region.world.checkInitialised.get() != ServerLevel.WORLD_INIT_CHECKED) {
@@ -1672,9 +1715,9 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             return scheduledEnd - System.nanoTime() > targetBuffer;
         };
         this.server.spark.tickStart(); // Paper - spark
-        new com.destroystokyo.paper.event.server.ServerTickStartEvent((int)region.getCurrentTick()).callEvent(); // Paper
+        new ServerTickStartEvent((int)region.getCurrentTick()).callEvent(); // Paper
         // Folia end - region threading
-        co.aikar.timings.TimingsManager.FULL_SERVER_TICK.startTiming(); // Paper
+        TimingsManager.FULL_SERVER_TICK.startTiming(); // Paper
         long i = startTime; // Folia - region threading
 
         // Paper start - move oversleep into full server tick
@@ -1690,28 +1733,28 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         // Folia start - region threading
         if (region != null) {
-            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.INTERNAL_TICK_TASKS); try { // Folia - profiler
+            profiler.startTimer(LProfilerRegistry.INTERNAL_TICK_TASKS); try { // Folia - profiler
             region.getTaskQueueData().drainTasks();
-            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.INTERNAL_TICK_TASKS); } // Folia - profiler
-            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PLUGIN_TICK_TASKS); try { // Folia - profiler
-            ((io.papermc.paper.threadedregions.scheduler.FoliaRegionScheduler)Bukkit.getRegionScheduler()).tick();
-            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PLUGIN_TICK_TASKS); } // Folia - profiler
+            } finally { profiler.stopTimer(LProfilerRegistry.INTERNAL_TICK_TASKS); } // Folia - profiler
+            profiler.startTimer(LProfilerRegistry.PLUGIN_TICK_TASKS); try { // Folia - profiler
+            ((FoliaRegionScheduler)Bukkit.getRegionScheduler()).tick();
+            } finally { profiler.stopTimer(LProfilerRegistry.PLUGIN_TICK_TASKS); } // Folia - profiler
             // now run all the entity schedulers
             // TODO there has got to be a more efficient variant of this crap
             long tickedEntitySchedulers = 0L; // Folia - profiler
-            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.ENTITY_SCHEDULER_TICK); try { // Folia - profiler
+            profiler.startTimer(LProfilerRegistry.ENTITY_SCHEDULER_TICK); try { // Folia - profiler
             for (Entity entity : region.world.getCurrentWorldData().getLocalEntitiesCopy()) {
-                if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(entity) || entity.isRemoved()) {
+                if (!TickThread.isTickThreadFor(entity) || entity.isRemoved()) {
                     continue;
                 }
-                org.bukkit.craftbukkit.entity.CraftEntity bukkit = entity.getBukkitEntityRaw();
+                CraftEntity bukkit = entity.getBukkitEntityRaw();
                 if (bukkit != null) {
                     bukkit.taskScheduler.executeTick();
                     ++tickedEntitySchedulers; // Folia - profiler
                 }
             }
-            profiler.addCounter(ca.spottedleaf.leafprofiler.LProfilerRegistry.ENTITY_SCHEDULERS_TICKED, tickedEntitySchedulers); // Folia - profiler
-            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.ENTITY_SCHEDULER_TICK); } // Folia - profiler
+            profiler.addCounter(LProfilerRegistry.ENTITY_SCHEDULERS_TICKED, tickedEntitySchedulers); // Folia - profiler
+            } finally { profiler.stopTimer(LProfilerRegistry.ENTITY_SCHEDULER_TICK); } // Folia - profiler
         }
         // Folia end - region threading
 
@@ -1725,13 +1768,13 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         // Folia - region threading
         // Paper start - Incremental chunk and player saving
-        int playerSaveInterval = io.papermc.paper.configuration.GlobalConfiguration.get().playerAutoSave.rate;
+        int playerSaveInterval = GlobalConfiguration.get().playerAutoSave.rate;
         if (playerSaveInterval < 0) {
             playerSaveInterval = autosavePeriod;
         }
         this.profiler.push("save");
-        final boolean fullSave = autosavePeriod > 0 && io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() % autosavePeriod == 0; // Folia - region threading
-        profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.AUTOSAVE); try { // Folia - profiler
+        final boolean fullSave = autosavePeriod > 0 && RegionizedServer.getCurrentTick() % autosavePeriod == 0; // Folia - region threading
+        profiler.startTimer(LProfilerRegistry.AUTOSAVE); try { // Folia - profiler
         try {
             this.isSaving = true;
             if (playerSaveInterval > 0) {
@@ -1745,25 +1788,25 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         } finally {
             this.isSaving = false;
         }
-        } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.AUTOSAVE); } // Folia - profiler
+        } finally { profiler.stopTimer(LProfilerRegistry.AUTOSAVE); } // Folia - profiler
         this.profiler.pop();
         // Paper end - Incremental chunk and player saving
         // Paper start - move executeAll() into full server tick timing
-        if (region == null) try (co.aikar.timings.Timing ignored = MinecraftTimings.processTasksTimer.startTiming()) { // Folia - region threading
+        if (region == null) try (Timing ignored = MinecraftTimings.processTasksTimer.startTiming()) { // Folia - region threading
             this.runAllTasks();
         }
         // Paper end
         // Paper start - Server Tick Events
         long endTime = System.nanoTime();
         long remaining = scheduledEnd - endTime; // Folia - region ticking
-        new com.destroystokyo.paper.event.server.ServerTickEndEvent((int)io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick(), ((double)(endTime - startTime) / 1000000D), remaining).callEvent(); // Folia - region ticking
+        new ServerTickEndEvent((int) RegionizedServer.getCurrentTick(), ((double)(endTime - startTime) / 1000000D), remaining).callEvent(); // Folia - region ticking
         this.server.spark.tickEnd(((double)(endTime - startTime) / 1000000D)); // Paper - spark // Folia - region ticking
         // Paper end - Server Tick Events
         this.profiler.push("tallying");
         // Folia - region threading
         this.profiler.pop();
-        org.spigotmc.WatchdogThread.tick(); // Spigot
-        co.aikar.timings.TimingsManager.FULL_SERVER_TICK.stopTiming(); // Paper
+        WatchdogThread.tick(); // Spigot
+        TimingsManager.FULL_SERVER_TICK.stopTiming(); // Paper
     }
 
     private void logTickMethodTime(long tickStartTime) {
@@ -1793,17 +1836,17 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private ServerStatus buildServerStatus() {
         ServerStatus.Players serverping_serverpingplayersample = this.buildPlayerStatus();
 
-        return new ServerStatus(io.papermc.paper.adventure.PaperAdventure.asVanilla(this.motd), Optional.of(serverping_serverpingplayersample), Optional.of(ServerStatus.Version.current()), Optional.ofNullable(this.statusIcon), this.enforceSecureProfile()); // Paper - Adventure
+        return new ServerStatus(PaperAdventure.asVanilla(this.motd), Optional.of(serverping_serverpingplayersample), Optional.of(ServerStatus.Version.current()), Optional.ofNullable(this.statusIcon), this.enforceSecureProfile()); // Paper - Adventure
     }
 
     private ServerStatus.Players buildPlayerStatus() {
-        List<ServerPlayer> list = new java.util.ArrayList<>(this.playerList.getPlayers()); // Folia - region threading
+        List<ServerPlayer> list = new ArrayList<>(this.playerList.getPlayers()); // Folia - region threading
         int i = this.getMaxPlayers();
 
         if (this.hidesOnlinePlayers()) {
             return new ServerStatus.Players(i, list.size(), List.of());
         } else {
-            int j = Math.min(list.size(), org.spigotmc.SpigotConfig.playerSample); // Paper - PaperServerListPingEvent
+            int j = Math.min(list.size(), SpigotConfig.playerSample); // Paper - PaperServerListPingEvent
             ObjectArrayList<GameProfile> objectarraylist = new ObjectArrayList(j);
             int k = Mth.nextInt(this.random, 0, list.size() - j);
 
@@ -1818,9 +1861,9 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
     }
 
-    public void tickChildren(BooleanSupplier shouldKeepTicking, io.papermc.paper.threadedregions.TickRegions.TickRegionData region) { // Folia - region threading
-        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
-        final io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData(); // Folia - regionised ticking
+    public void tickChildren(BooleanSupplier shouldKeepTicking, TickRegions.TickRegionData region) { // Folia - region threading
+        final RegionizedProfiler.Handle profiler = TickRegionScheduler.getProfiler(); // Folia - profiler
+        final RegionizedWorldData regionizedWorldData = TickRegionScheduler.getCurrentRegionizedWorldData(); // Folia - regionised ticking
         if (region == null) this.getPlayerList().getPlayers().forEach((entityplayer) -> { // Folia - region threading
             entityplayer.connection.suspendFlushing();
         });
@@ -1852,7 +1895,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             long worldTime = level.getGameTime();
             final ClientboundSetTimePacket worldPacket = new ClientboundSetTimePacket(worldTime, dayTime, doDaylight);
             for (Player entityhuman : level.getLocalPlayers()) { // Folia - region threading
-                if (!(entityhuman instanceof ServerPlayer) || (io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() + entityhuman.getId()) % 20 != 0) { // Folia - region threading
+                if (!(entityhuman instanceof ServerPlayer) || (RegionizedServer.getCurrentTick() + entityhuman.getId()) % 20 != 0) { // Folia - region threading
                     continue;
                 }
                 ServerPlayer entityplayer = (ServerPlayer) entityhuman;
@@ -1908,9 +1951,9 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.profiler.popPush("connection");
         MinecraftTimings.connectionTimer.startTiming(); // Spigot // Paper
         if (region == null) this.getConnection().tick(); // Folia - region threading
-        profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CONNECTION_TICK); try { // Folia - profiler
+        profiler.startTimer(LProfilerRegistry.CONNECTION_TICK); try { // Folia - profiler
         if (region != null) regionizedWorldData.tickConnections(); // Folia - region threading
-        } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CONNECTION_TICK); } // Folia - profiler
+        } finally { profiler.stopTimer(LProfilerRegistry.CONNECTION_TICK); } // Folia - profiler
         MinecraftTimings.connectionTimer.stopTiming(); // Spigot // Paper
         this.profiler.popPush("players");
         MinecraftTimings.playerListTimer.startTiming(); // Spigot // Paper
@@ -2032,7 +2075,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     @DontObfuscate
     public String getServerModName() {
-        return io.papermc.paper.ServerBuildInfo.buildInfo().brandName(); // Paper
+        return ServerBuildInfo.buildInfo().brandName(); // Paper
     }
 
     public SystemReport fillSystemReport(SystemReport details) {
@@ -2079,7 +2122,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     @Override
     public void sendSystemMessage(Component message) {
-        MinecraftServer.LOGGER.info(io.papermc.paper.adventure.PaperAdventure.ANSI_SERIALIZER.serialize(io.papermc.paper.adventure.PaperAdventure.asAdventure(message))); // Paper - Log message with colors
+        MinecraftServer.LOGGER.info(PaperAdventure.ANSI_SERIALIZER.serialize(PaperAdventure.asAdventure(message))); // Paper - Log message with colors
     }
 
     public KeyPair getKeyPair() {
@@ -2166,12 +2209,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.isDemo = demo;
     }
 
-    public Optional<MinecraftServer.ServerResourcePackInfo> getServerResourcePack() {
+    public Optional<ServerResourcePackInfo> getServerResourcePack() {
         return Optional.empty();
     }
 
     public boolean isResourcePackRequired() {
-        return this.getServerResourcePack().filter(MinecraftServer.ServerResourcePackInfo::isRequired).isPresent();
+        return this.getServerResourcePack().filter(ServerResourcePackInfo::isRequired).isPresent();
     }
 
     public abstract boolean isDedicatedServer();
@@ -2224,12 +2267,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     @Override
     public String getMotd() {
-        return net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().serialize(this.motd); // Paper - Adventure
+        return LegacyComponentSerializer.legacySection().serialize(this.motd); // Paper - Adventure
     }
 
     public void setMotd(String motd) {
         // Paper start - Adventure
-        this.motd = net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserializeOr(motd, net.kyori.adventure.text.Component.empty());
+        this.motd = LegacyComponentSerializer.legacySection().deserializeOr(motd, net.kyori.adventure.text.Component.empty());
     }
 
     public net.kyori.adventure.text.Component motd() {
@@ -2334,8 +2377,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // Folia start - region threading
         if (true) {
             // we don't need this to notify the global tick region
-            io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTaskWithoutNotify(() -> {
-                io.papermc.paper.threadedregions.RegionizedServer.getInstance().invalidateStatus();
+            RegionizedServer.getInstance().addTaskWithoutNotify(() -> {
+                RegionizedServer.getInstance().invalidateStatus();
             });
             return;
         }
@@ -2356,7 +2399,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public void executeIfPossible(Runnable runnable) {
         if (true) throw new UnsupportedOperationException(); // Folia - region threading
         if (this.isStopped()) {
-            throw new io.papermc.paper.util.ServerStopRejectedExecutionException("Server already shutting down"); // Paper - do not prematurely disconnect players on stop
+            throw new ServerStopRejectedExecutionException("Server already shutting down"); // Paper - do not prematurely disconnect players on stop
         } else {
             super.executeIfPossible(runnable);
         }
@@ -2396,70 +2439,77 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     // Paper start - Add ServerResourcesReloadedEvent
-    @Deprecated @io.papermc.paper.annotation.DoNotUse
+    @Deprecated @DoNotUse
     public CompletableFuture<Void> reloadResources(Collection<String> dataPacks) {
-        return this.reloadResources(dataPacks, io.papermc.paper.event.server.ServerResourcesReloadedEvent.Cause.PLUGIN);
+        return this.reloadResources(dataPacks, ServerResourcesReloadedEvent.Cause.PLUGIN);
     }
-    public CompletableFuture<Void> reloadResources(Collection<String> dataPacks, io.papermc.paper.event.server.ServerResourcesReloadedEvent.Cause cause) {
+    public CompletableFuture<Void> reloadResources(Collection<String> dataPacks, ServerResourcesReloadedEvent.Cause cause) {
         // Paper end - Add ServerResourcesReloadedEvent
-        CompletableFuture<Void> completablefuture = CompletableFuture.supplyAsync(() -> {
-            Stream<String> stream = dataPacks.stream(); // CraftBukkit - decompile error
-            PackRepository resourcepackrepository = this.packRepository;
-
-            Objects.requireNonNull(this.packRepository);
-            return stream.<Pack>map(resourcepackrepository::getPack).filter(Objects::nonNull).map(Pack::open).collect(ImmutableList.toImmutableList()); // CraftBukkit - decompile error // Paper - decompile error // todo: is this needed anymore?
-        }, this).thenCompose((immutablelist) -> {
-            MultiPackResourceManager resourcemanager = new MultiPackResourceManager(PackType.SERVER_DATA, immutablelist);
-
-            return ReloadableServerResources.loadResources(resourcemanager, this.registries, this.worldData.enabledFeatures(), this.isDedicatedServer() ? Commands.CommandSelection.DEDICATED : Commands.CommandSelection.INTEGRATED, this.getFunctionCompilationLevel(), this.executor, this).whenComplete((datapackresources, throwable) -> {
-                if (throwable != null) {
-                    resourcemanager.close();
+        CompletableFuture<Void> completablefuture = null;
+        if(!this.isSameThread()) {
+            completablefuture = CompletableFuture.supplyAsync(() -> {
+                Stream<String> stream = dataPacks.stream(); // CraftBukkit - decompile error
+                PackRepository resourcepackrepository = this.packRepository;
+
+                Objects.requireNonNull(this.packRepository);
+                return stream.<Pack>map(resourcepackrepository::getPack).filter(Objects::nonNull).map(Pack::open).collect(ImmutableList.toImmutableList()); // CraftBukkit - decompile error // Paper - decompile error // todo: is this needed anymore?
+            }, this).thenCompose((immutablelist) -> {
+                MultiPackResourceManager resourcemanager = new MultiPackResourceManager(PackType.SERVER_DATA, immutablelist);
+
+                return ReloadableServerResources.loadResources(resourcemanager, this.registries, this.worldData.enabledFeatures(), this.isDedicatedServer() ? Commands.CommandSelection.DEDICATED : Commands.CommandSelection.INTEGRATED, this.getFunctionCompilationLevel(), this.executor, this).whenComplete((datapackresources, throwable) -> {
+                    if (throwable != null) {
+                        resourcemanager.close();
+                    }
+
+                }).thenApply((datapackresources) -> {
+                    return new ReloadableResources(resourcemanager, datapackresources);
+                });
+            }).thenAcceptAsync((minecraftserver_reloadableresources) -> {
+                PaperBrigadier.moveBukkitCommands(this.resources.managers().getCommands(), minecraftserver_reloadableresources.managers().commands); // Paper
+                this.resources.close();
+                this.resources = minecraftserver_reloadableresources;
+                this.packRepository.setSelected(dataPacks);
+                WorldDataConfiguration worlddataconfiguration = new WorldDataConfiguration(MinecraftServer.getSelectedPacks(this.packRepository, true), this.worldData.enabledFeatures());
+
+                this.worldData.setDataConfiguration(worlddataconfiguration);
+                this.resources.managers.updateRegistryTags();
+                this.potionBrewing = this.potionBrewing.reload(this.worldData.enabledFeatures()); // Paper - Custom Potion Mixes
+                // Paper start
+                if (Thread.currentThread() != this.serverThread) {
+                    return;
                 }
+                // this.getPlayerList().saveAll(); // Paper - we don't need to save everything, just advancements // TODO Move this to a different patch
+                for (ServerPlayer player : this.getPlayerList().getPlayers()) {
+                    player.getAdvancements().save();
+                }
+                // Paper end
+                this.getPlayerList().reloadResources();
+                this.functionManager.replaceLibrary(this.resources.managers.getFunctionLibrary());
+                this.structureTemplateManager.onResourceManagerReload(this.resources.resourceManager);
+                CraftBlockData.reloadCache(); // Paper - cache block data strings, they can be defined by datapacks so refresh it here
+                // Paper start - brigadier command API
+                PaperCommands.INSTANCE.setValid(); // reset invalid state for event fire below
+                LifecycleEventRunner.INSTANCE.callReloadableRegistrarEvent(LifecycleEvents.COMMANDS, PaperCommands.INSTANCE, Plugin.class, ReloadableRegistrarEvent.Cause.RELOAD); // call commands event for regular plugins
+                final SimpleHelpMap helpMap = (SimpleHelpMap) this.server.getHelpMap();
+                helpMap.clear();
+                helpMap.initializeGeneralTopics();
+                helpMap.initializeCommands();
+                this.server.syncCommands(); // Refresh commands after event
+                // Paper end
+                new ServerResourcesReloadedEvent(cause).callEvent(); // Paper - fire after everything has been reloaded
+            }, this);
 
-            }).thenApply((datapackresources) -> {
-                return new MinecraftServer.ReloadableResources(resourcemanager, datapackresources);
-            });
-        }).thenAcceptAsync((minecraftserver_reloadableresources) -> {
-            io.papermc.paper.command.brigadier.PaperBrigadier.moveBukkitCommands(this.resources.managers().getCommands(), minecraftserver_reloadableresources.managers().commands); // Paper
-            this.resources.close();
-            this.resources = minecraftserver_reloadableresources;
-            this.packRepository.setSelected(dataPacks);
-            WorldDataConfiguration worlddataconfiguration = new WorldDataConfiguration(MinecraftServer.getSelectedPacks(this.packRepository, true), this.worldData.enabledFeatures());
-
-            this.worldData.setDataConfiguration(worlddataconfiguration);
-            this.resources.managers.updateRegistryTags();
-            this.potionBrewing = this.potionBrewing.reload(this.worldData.enabledFeatures()); // Paper - Custom Potion Mixes
-            // Paper start
-            if (Thread.currentThread() != this.serverThread) {
-                return;
-            }
-            // this.getPlayerList().saveAll(); // Paper - we don't need to save everything, just advancements // TODO Move this to a different patch
-            for (ServerPlayer player : this.getPlayerList().getPlayers()) {
-                player.getAdvancements().save();
-            }
-            // Paper end
-            this.getPlayerList().reloadResources();
-            this.functionManager.replaceLibrary(this.resources.managers.getFunctionLibrary());
-            this.structureTemplateManager.onResourceManagerReload(this.resources.resourceManager);
-            org.bukkit.craftbukkit.block.data.CraftBlockData.reloadCache(); // Paper - cache block data strings, they can be defined by datapacks so refresh it here
-            // Paper start - brigadier command API
-            io.papermc.paper.command.brigadier.PaperCommands.INSTANCE.setValid(); // reset invalid state for event fire below
-            io.papermc.paper.plugin.lifecycle.event.LifecycleEventRunner.INSTANCE.callReloadableRegistrarEvent(io.papermc.paper.plugin.lifecycle.event.types.LifecycleEvents.COMMANDS, io.papermc.paper.command.brigadier.PaperCommands.INSTANCE, org.bukkit.plugin.Plugin.class, io.papermc.paper.plugin.lifecycle.event.registrar.ReloadableRegistrarEvent.Cause.RELOAD); // call commands event for regular plugins
-            final org.bukkit.craftbukkit.help.SimpleHelpMap helpMap = (org.bukkit.craftbukkit.help.SimpleHelpMap) this.server.getHelpMap();
-            helpMap.clear();
-            helpMap.initializeGeneralTopics();
-            helpMap.initializeCommands();
-            this.server.syncCommands(); // Refresh commands after event
-            // Paper end
-            new io.papermc.paper.event.server.ServerResourcesReloadedEvent(cause).callEvent(); // Paper - fire after everything has been reloaded
-        }, this);
+            return completablefuture;
+        }
 
-        if (this.isSameThread()) {
-            Objects.requireNonNull(completablefuture);
-            this.managedBlock(completablefuture::isDone);
+        if (false) {
+            if (this.isSameThread()) {
+                Objects.requireNonNull(completablefuture);
+                this.managedBlock(completablefuture::isDone);
+            }
         }
 
-        return completablefuture;
+        return CompletableFuture.runAsync(() -> {});
     }
 
     public static WorldDataConfiguration configurePackRepository(PackRepository resourcePackManager, WorldDataConfiguration dataConfiguration, boolean initMode, boolean safeMode) {
@@ -2584,7 +2634,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 ServerPlayer entityplayer = (ServerPlayer) iterator.next();
 
                 if (!whitelist.isWhiteListed(entityplayer.getGameProfile()) && !this.getPlayerList().isOp(entityplayer.getGameProfile())) { // Paper - Fix kicking ops when whitelist is reloaded (MC-171420)
-                    entityplayer.connection.disconnect(net.kyori.adventure.text.Component.text(org.spigotmc.SpigotConfig.whitelistMessage), org.bukkit.event.player.PlayerKickEvent.Cause.WHITELIST); // Paper - use configurable message & kick event cause
+                    entityplayer.connection.disconnect(net.kyori.adventure.text.Component.text(SpigotConfig.whitelistMessage), PlayerKickEvent.Cause.WHITELIST); // Paper - use configurable message & kick event cause
                 }
             }
 
@@ -2660,7 +2710,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     public long getAverageTickTimeNanos() {
         // Folia start - region threading
-        if (io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentTickingTask() instanceof io.papermc.paper.threadedregions.TickRegionScheduler.RegionScheduleHandle handle) {
+        if (TickRegionScheduler.getCurrentTickingTask() instanceof TickRegionScheduler.RegionScheduleHandle handle) {
             return (long)Math.ceil(handle.getTickReport5s(System.nanoTime()).timePerTickData().segmentAll().average());
         }
         return 0L;
@@ -2908,7 +2958,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     // Paper start - rewrite chunk system
     @Override
     public boolean isSameThread() {
-        return ca.spottedleaf.moonrise.common.util.TickThread.isTickThread();
+        return TickThread.isTickThread();
     }
     // Paper end - rewrite chunk system
 
@@ -3041,7 +3091,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     public void logChatMessage(Component message, ChatType.Bound params, @Nullable String prefix) {
         // Paper start
-        net.kyori.adventure.text.Component s1 = io.papermc.paper.adventure.PaperAdventure.asAdventure(params.decorate(message));
+        net.kyori.adventure.text.Component s1 = PaperAdventure.asAdventure(params.decorate(message));
 
         if (prefix != null) {
             MinecraftServer.COMPONENT_LOGGER.info("[{}] {}", prefix, s1);
@@ -3052,10 +3102,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     }
 
-    public final java.util.concurrent.ExecutorService chatExecutor = java.util.concurrent.Executors.newCachedThreadPool(
-            new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon(true).setNameFormat("Async Chat Thread - #%d").setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(net.minecraft.server.MinecraftServer.LOGGER)).build()); // Paper
+    public final ExecutorService chatExecutor = Executors.newCachedThreadPool(
+            new ThreadFactoryBuilder().setDaemon(true).setNameFormat("Async Chat Thread - #%d").setUncaughtExceptionHandler(new DefaultUncaughtExceptionHandlerWithName(MinecraftServer.LOGGER)).build()); // Paper
 
-    public final ChatDecorator improvedChatDecorator = new io.papermc.paper.adventure.ImprovedChatDecorator(this); // Paper - adventure
+    public final ChatDecorator improvedChatDecorator = new ImprovedChatDecorator(this); // Paper - adventure
     public ChatDecorator getChatDecorator() {
         return this.improvedChatDecorator; // Paper - support async chat decoration events
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index dee23b4b96b7f2c6af54a6affe385b183479f8cc..8118c33171e03c08a27e57e9a18c2986b3293ea2 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -1133,7 +1133,11 @@ public final class CraftServer implements Server {
         }
 
         Plugin[] pluginClone = pluginManager.getPlugins().clone(); // Paper
-        this.commandMap.clearCommands(); // Paper - Move command reloading up
+
+        if (false) {
+            this.commandMap.clearCommands(); // Paper - Move command reloading up
+        }
+
         this.pluginManager.clearPlugins();
         // Paper - move up
         // Paper start

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: xuyin <1573880184@qq.com>
Date: Fri, 24 Jan 2025 21:02:41 +0800
Subject: [PATCH] Fixed bukkit teleport.


diff --git a/src/main/java/com/menthamc/mint/config/modules/fix/BukkitTeleportFixConfig.java b/src/main/java/com/menthamc/mint/config/modules/fix/BukkitTeleportFixConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..43b2d317c6cc1d88d540b91bd79b392b1e4af6e7
--- /dev/null
+++ b/src/main/java/com/menthamc/mint/config/modules/fix/BukkitTeleportFixConfig.java
@@ -0,0 +1,20 @@
+package com.menthamc.mint.config.modules.fix;
+
+import com.menthamc.mint.config.ConfigCategory;
+import com.menthamc.mint.config.ConfigField;
+import com.menthamc.mint.config.Configuration;
+import com.menthamc.mint.config.IConfigModule;
+
+@Configuration(
+        name = "bukkit_teleport_fix",
+        type = ConfigCategory.fix,
+        comment = {
+                "Fixed Bukkit entity teleportation API broken by Folia",
+                "After enabled, the plugin can directly use the teleport method of the Entity, and does not need to use the teleportAsync method provided by Folia",
+                "`true` is enabled and `false` is disabled."
+        }
+)
+public class BukkitTeleportFixConfig implements IConfigModule {
+    @ConfigField
+    public static boolean enabled = true;
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 7be80f2774b5ec3d0bede096da8f2b6d1cf7b09b..879d27d4f311fe511506cba461509bb4973f69d8 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -8,6 +8,9 @@ import com.google.common.collect.Lists;
 import java.util.List;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.ExecutionException;
+
+import com.menthamc.mint.config.modules.fix.BukkitTeleportFixConfig;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.Tag;
 import net.minecraft.network.chat.Component;
@@ -241,61 +244,71 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
 
     @Override
     public boolean teleport(Location location, TeleportCause cause, io.papermc.paper.entity.TeleportFlag... flags) {
-        // Folia start - region threading
-        if (true) {
-            throw new UnsupportedOperationException("Must use teleportAsync while in region threading");
-        }
-        // Folia end - region threading
-        // Paper end
-        Preconditions.checkArgument(location != null, "location cannot be null");
-        location.checkFinite();
-        // Paper start - Teleport passenger API
-        Set<io.papermc.paper.entity.TeleportFlag> flagSet = Set.of(flags);
-        boolean dismount = !flagSet.contains(io.papermc.paper.entity.TeleportFlag.EntityState.RETAIN_VEHICLE);
-        boolean ignorePassengers = flagSet.contains(io.papermc.paper.entity.TeleportFlag.EntityState.RETAIN_PASSENGERS);
-        // Don't allow teleporting between worlds while keeping passengers
-        if (flagSet.contains(io.papermc.paper.entity.TeleportFlag.EntityState.RETAIN_PASSENGERS) && this.entity.isVehicle() && location.getWorld() != this.getWorld()) {
-            return false;
-        }
+        // Mint start - Re-implemented Bukkit native delivery API
+        if(!BukkitTeleportFixConfig.enabled) {
+            // Folia start - region threading
+            if (true) {
+                throw new UnsupportedOperationException("Must use teleportAsync while in region threading");
+            }
+            // Folia end - region threading
+            // Paper end
+            Preconditions.checkArgument(location != null, "location cannot be null");
+            location.checkFinite();
+            // Paper start - Teleport passenger API
+            Set<io.papermc.paper.entity.TeleportFlag> flagSet = Set.of(flags);
+            boolean dismount = !flagSet.contains(io.papermc.paper.entity.TeleportFlag.EntityState.RETAIN_VEHICLE);
+            boolean ignorePassengers = flagSet.contains(io.papermc.paper.entity.TeleportFlag.EntityState.RETAIN_PASSENGERS);
+            // Don't allow teleporting between worlds while keeping passengers
+            if (flagSet.contains(io.papermc.paper.entity.TeleportFlag.EntityState.RETAIN_PASSENGERS) && this.entity.isVehicle() && location.getWorld() != this.getWorld()) {
+                return false;
+            }
 
-        // Don't allow to teleport between worlds if remaining on vehicle
-        if (!dismount && this.entity.isPassenger() && location.getWorld() != this.getWorld()) {
-            return false;
-        }
-        // Paper end
+            // Don't allow to teleport between worlds if remaining on vehicle
+            if (!dismount && this.entity.isPassenger() && location.getWorld() != this.getWorld()) {
+                return false;
+            }
+            // Paper end
 
-        if ((!ignorePassengers && this.entity.isVehicle()) || this.entity.isRemoved()) { // Paper - Teleport passenger API
-            return false;
-        }
+            if ((!ignorePassengers && this.entity.isVehicle()) || this.entity.isRemoved()) { // Paper - Teleport passenger API
+                return false;
+            }
 
-        // Paper start - fix teleport event not being called
-        org.bukkit.event.entity.EntityTeleportEvent event = new org.bukkit.event.entity.EntityTeleportEvent(
-            this, this.getLocation(), location);
-        // cancelling the event is handled differently for players and entities,
-        // entities just stop teleporting, players will still teleport to the "from" location of the event
-        if (!event.callEvent() || event.getTo() == null) {
-            return false;
-        }
-        location = event.getTo();
-        // Paper end
+            // Paper start - fix teleport event not being called
+            org.bukkit.event.entity.EntityTeleportEvent event = new org.bukkit.event.entity.EntityTeleportEvent(
+                    this, this.getLocation(), location);
+            // cancelling the event is handled differently for players and entities,
+            // entities just stop teleporting, players will still teleport to the "from" location of the event
+            if (!event.callEvent() || event.getTo() == null) {
+                return false;
+            }
+            location = event.getTo();
+            // Paper end
+
+            // If this entity is riding another entity, we must dismount before teleporting.
+            if (dismount) this.entity.stopRiding(); // Paper - Teleport passenger API
+
+            // Let the server handle cross world teleports
+            if (location.getWorld() != null && !location.getWorld().equals(this.getWorld())) {
+                // Prevent teleportation to an other world during world generation
+                Preconditions.checkState(!this.entity.generation, "Cannot teleport entity to an other world during world generation");
+                this.entity.changeDimension(new DimensionTransition(((CraftWorld) location.getWorld()).getHandle(), CraftLocation.toVec3D(location), Vec3.ZERO, location.getPitch(), location.getYaw(), DimensionTransition.DO_NOTHING, TeleportCause.PLUGIN));
+                return true;
+            }
 
-        // If this entity is riding another entity, we must dismount before teleporting.
-        if (dismount) this.entity.stopRiding(); // Paper - Teleport passenger API
+            // entity.setLocation() throws no event, and so cannot be cancelled
+            entity.moveTo(location.getX(), location.getY(), location.getZ(), location.getYaw(), location.getPitch()); // Paper - use proper moveTo, as per vanilla teleporting
+            // SPIGOT-619: Force sync head rotation also
+            this.entity.setYHeadRot(location.getYaw());
 
-        // Let the server handle cross world teleports
-        if (location.getWorld() != null && !location.getWorld().equals(this.getWorld())) {
-            // Prevent teleportation to an other world during world generation
-            Preconditions.checkState(!this.entity.generation, "Cannot teleport entity to an other world during world generation");
-            this.entity.changeDimension(new DimensionTransition(((CraftWorld) location.getWorld()).getHandle(), CraftLocation.toVec3D(location), Vec3.ZERO, location.getPitch(), location.getYaw(), DimensionTransition.DO_NOTHING, TeleportCause.PLUGIN));
             return true;
+        } else {
+            try {
+                return this.teleportAsync(location, cause, flags).get();
+            } catch (InterruptedException | ExecutionException e) {
+                throw new RuntimeException(e);
+            }
         }
-
-        // entity.setLocation() throws no event, and so cannot be cancelled
-        entity.moveTo(location.getX(), location.getY(), location.getZ(), location.getYaw(), location.getPitch()); // Paper - use proper moveTo, as per vanilla teleporting
-        // SPIGOT-619: Force sync head rotation also
-        this.entity.setYHeadRot(location.getYaw());
-
-        return true;
+        // Mint end - Re-implemented Bukkit native delivery API
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 12a2da086f249b3dbd61e5749b9856a2fce9ac7b..a2c27797ce44e62fd8731de304a78ee6395ad989 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -3,6 +3,7 @@ package org.bukkit.craftbukkit.entity;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.io.BaseEncoding;
+import com.menthamc.mint.config.modules.fix.BukkitTeleportFixConfig;
 import com.mojang.authlib.GameProfile;
 import com.mojang.datafixers.util.Pair;
 import io.netty.buffer.Unpooled;
@@ -32,6 +33,7 @@ import java.util.Set;
 import java.util.UUID;
 import java.util.WeakHashMap;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.annotation.Nullable;
@@ -1412,107 +1414,115 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public boolean teleport(Location location, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause cause, io.papermc.paper.entity.TeleportFlag... flags) {
-        // Folia start - region threading
-        if (true) {
-            throw new UnsupportedOperationException("Must use teleportAsync while in region threading");
-        }
-        // Folia end - region threading
-        Set<io.papermc.paper.entity.TeleportFlag.Relative> relativeArguments;
-        Set<io.papermc.paper.entity.TeleportFlag> allFlags;
-        if (flags.length == 0) {
-            relativeArguments = Set.of();
-            allFlags = Set.of();
-        } else {
-            relativeArguments = java.util.EnumSet.noneOf(io.papermc.paper.entity.TeleportFlag.Relative.class);
-            allFlags = new HashSet<>();
-            for (io.papermc.paper.entity.TeleportFlag flag : flags) {
-                if (flag instanceof final io.papermc.paper.entity.TeleportFlag.Relative relativeTeleportFlag) {
-                    relativeArguments.add(relativeTeleportFlag);
+        if (!BukkitTeleportFixConfig.enabled) {
+            // Folia start - region threading
+            if (true) {
+                throw new UnsupportedOperationException("Must use teleportAsync while in region threading");
+            }
+            // Folia end - region threading
+            Set<io.papermc.paper.entity.TeleportFlag.Relative> relativeArguments;
+            Set<io.papermc.paper.entity.TeleportFlag> allFlags;
+            if (flags.length == 0) {
+                relativeArguments = Set.of();
+                allFlags = Set.of();
+            } else {
+                relativeArguments = java.util.EnumSet.noneOf(io.papermc.paper.entity.TeleportFlag.Relative.class);
+                allFlags = new HashSet<>();
+                for (io.papermc.paper.entity.TeleportFlag flag : flags) {
+                    if (flag instanceof final io.papermc.paper.entity.TeleportFlag.Relative relativeTeleportFlag) {
+                        relativeArguments.add(relativeTeleportFlag);
+                    }
+                    allFlags.add(flag);
                 }
-                allFlags.add(flag);
             }
-        }
-        boolean dismount = !allFlags.contains(io.papermc.paper.entity.TeleportFlag.EntityState.RETAIN_VEHICLE);
-        boolean ignorePassengers = allFlags.contains(io.papermc.paper.entity.TeleportFlag.EntityState.RETAIN_PASSENGERS);
-        // Paper end - Teleport API
-        Preconditions.checkArgument(location != null, "location");
-        Preconditions.checkArgument(location.getWorld() != null, "location.world");
-        // Paper start - Teleport passenger API
-        // Don't allow teleporting between worlds while keeping passengers
-        if (ignorePassengers && entity.isVehicle() && location.getWorld() != this.getWorld()) {
-            return false;
-        }
-
-        // Don't allow to teleport between worlds if remaining on vehicle
-        if (!dismount && entity.isPassenger() && location.getWorld() != this.getWorld()) {
-            return false;
-        }
-        // Paper end
-        location.checkFinite();
-
-        ServerPlayer entity = this.getHandle();
+            boolean dismount = !allFlags.contains(io.papermc.paper.entity.TeleportFlag.EntityState.RETAIN_VEHICLE);
+            boolean ignorePassengers = allFlags.contains(io.papermc.paper.entity.TeleportFlag.EntityState.RETAIN_PASSENGERS);
+            // Paper end - Teleport API
+            Preconditions.checkArgument(location != null, "location");
+            Preconditions.checkArgument(location.getWorld() != null, "location.world");
+            // Paper start - Teleport passenger API
+            // Don't allow teleporting between worlds while keeping passengers
+            if (ignorePassengers && entity.isVehicle() && location.getWorld() != this.getWorld()) {
+                return false;
+            }
 
-        if (this.getHealth() == 0 || entity.isRemoved()) {
-            return false;
-        }
+            // Don't allow to teleport between worlds if remaining on vehicle
+            if (!dismount && entity.isPassenger() && location.getWorld() != this.getWorld()) {
+                return false;
+            }
+            // Paper end
+            location.checkFinite();
 
-        if (entity.connection == null) {
-            return false;
-        }
+            ServerPlayer entity = this.getHandle();
 
-        if (entity.isVehicle() && !ignorePassengers) { // Paper - Teleport API
-            return false;
-        }
+            if (this.getHealth() == 0 || entity.isRemoved()) {
+                return false;
+            }
 
-        // From = Players current Location
-        Location from = this.getLocation();
-        // To = Players new Location if Teleport is Successful
-        Location to = location;
-        // Create & Call the Teleport Event.
-        PlayerTeleportEvent event = new PlayerTeleportEvent(this, from, to, cause, Set.copyOf(relativeArguments)); // Paper - Teleport API
-        this.server.getPluginManager().callEvent(event);
+            if (entity.connection == null) {
+                return false;
+            }
 
-        // Return False to inform the Plugin that the Teleport was unsuccessful/cancelled.
-        if (event.isCancelled()) {
-            return false;
-        }
+            if (entity.isVehicle() && !ignorePassengers) { // Paper - Teleport API
+                return false;
+            }
 
-        // If this player is riding another entity, we must dismount before teleporting.
-        if (dismount) entity.stopRiding(); // Paper - Teleport API
+            // From = Players current Location
+            Location from = this.getLocation();
+            // To = Players new Location if Teleport is Successful
+            Location to = location;
+            // Create & Call the Teleport Event.
+            PlayerTeleportEvent event = new PlayerTeleportEvent(this, from, to, cause, Set.copyOf(relativeArguments)); // Paper - Teleport API
+            this.server.getPluginManager().callEvent(event);
+
+            // Return False to inform the Plugin that the Teleport was unsuccessful/cancelled.
+            if (event.isCancelled()) {
+                return false;
+            }
 
-        // SPIGOT-5509: Wakeup, similar to riding
-        if (this.isSleeping()) {
-            this.wakeup(false);
-        }
+            // If this player is riding another entity, we must dismount before teleporting.
+            if (dismount) entity.stopRiding(); // Paper - Teleport API
 
-        // Update the From Location
-        from = event.getFrom();
-        // Grab the new To Location dependent on whether the event was cancelled.
-        to = event.getTo();
-        // Grab the To and From World Handles.
-        ServerLevel fromWorld = ((CraftWorld) from.getWorld()).getHandle();
-        ServerLevel toWorld = ((CraftWorld) to.getWorld()).getHandle();
+            // SPIGOT-5509: Wakeup, similar to riding
+            if (this.isSleeping()) {
+                this.wakeup(false);
+            }
 
-        // Close any foreign inventory
-        if (this.getHandle().containerMenu != this.getHandle().inventoryMenu && !allFlags.contains(io.papermc.paper.entity.TeleportFlag.EntityState.RETAIN_OPEN_INVENTORY)) { // Paper
-            this.getHandle().closeContainer(org.bukkit.event.inventory.InventoryCloseEvent.Reason.TELEPORT); // Paper - Inventory close reason
-        }
+            // Update the From Location
+            from = event.getFrom();
+            // Grab the new To Location dependent on whether the event was cancelled.
+            to = event.getTo();
+            // Grab the To and From World Handles.
+            ServerLevel fromWorld = ((CraftWorld) from.getWorld()).getHandle();
+            ServerLevel toWorld = ((CraftWorld) to.getWorld()).getHandle();
+
+            // Close any foreign inventory
+            if (this.getHandle().containerMenu != this.getHandle().inventoryMenu && !allFlags.contains(io.papermc.paper.entity.TeleportFlag.EntityState.RETAIN_OPEN_INVENTORY)) { // Paper
+                this.getHandle().closeContainer(org.bukkit.event.inventory.InventoryCloseEvent.Reason.TELEPORT); // Paper - Inventory close reason
+            }
 
-        // Check if the fromWorld and toWorld are the same.
-        if (fromWorld == toWorld) {
-            // Paper start - Teleport API
-            final Set<net.minecraft.world.entity.RelativeMovement> nms = java.util.EnumSet.noneOf(net.minecraft.world.entity.RelativeMovement.class);
-            for (final io.papermc.paper.entity.TeleportFlag.Relative bukkit : relativeArguments) {
-                nms.add(toNmsRelativeFlag(bukkit));
+            // Check if the fromWorld and toWorld are the same.
+            if (fromWorld == toWorld) {
+                // Paper start - Teleport API
+                final Set<net.minecraft.world.entity.RelativeMovement> nms = java.util.EnumSet.noneOf(net.minecraft.world.entity.RelativeMovement.class);
+                for (final io.papermc.paper.entity.TeleportFlag.Relative bukkit : relativeArguments) {
+                    nms.add(toNmsRelativeFlag(bukkit));
+                }
+                entity.connection.internalTeleport(to.getX(), to.getY(), to.getZ(), to.getYaw(), to.getPitch(), nms);
+                // Paper end - Teleport API
+            } else {
+                entity.portalProcess = null; // SPIGOT-7785: there is no need to carry this over as it contains the old world/location and we might run into trouble if there is a portal in the same spot in both worlds
+                // The respawn reason should never be used if the passed location is non null.
+                this.server.getHandle().respawn(entity, true, Entity.RemovalReason.CHANGED_DIMENSION, null, to);
             }
-            entity.connection.internalTeleport(to.getX(), to.getY(), to.getZ(), to.getYaw(), to.getPitch(), nms);
-            // Paper end - Teleport API
+            return true;
         } else {
-            entity.portalProcess = null; // SPIGOT-7785: there is no need to carry this over as it contains the old world/location and we might run into trouble if there is a portal in the same spot in both worlds
-            // The respawn reason should never be used if the passed location is non null.
-            this.server.getHandle().respawn(entity, true, Entity.RemovalReason.CHANGED_DIMENSION, null, to);
+            try {
+                return this.teleportAsync(location, cause, flags).get();
+            } catch (InterruptedException | ExecutionException e) {
+                throw new RuntimeException(e);
+            }
         }
-        return true;
     }
 
     @Override
